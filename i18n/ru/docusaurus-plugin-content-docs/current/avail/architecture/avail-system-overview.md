---
id: avail-system-overview
title: Обзор системы
sidebar_label: System Overview
description: Узнайте о архитектуре цепочки Avail
keywords:
  - docs
  - polygon
  - avail
  - data
  - availability
  - architecture
image: https://wiki.polygon.technology/img/thumbnail/polygon-avail.png
slug: avail-system-overview
---

# Обзор системы {#system-overview}

## Модульность {#modularity}

В настоящее время монолитные blockchain такие как Ethereum, не могут эффективно справиться с исполнением, расчетом и наличием данных.

Модуляция выполнения в blockchains — это то, что пытаются сделать модели цепочки с rollup-centric rollup. Это может хорошо работать, когда слои расчетов и доступности данных находятся на одном уровне, который является подходом к rollups Ethereum. Тем не менее, при работе с rollups необходимо учитывать компромисс, поскольку конструкция роллапа может быть более безопасным в зависимости от безопасности слоя доступности данных, но по сути будет более сложным для масштаба.

Однако гранулированный дизайн создает различные слои для легкого протокола, например, микросервисы. Затем общая сеть становится коллекцией протоколов с свободным соединением. Пример — это уровень доступности данных, который специализируется только на наличии данных. Polygon Avail — это блокчейн, основанный на субстрате, два уровня для наличия данных.

:::info Среда выполнения Substrate

Хотя Avail основан на кодовой базе Substrate, он включает изменения в структуру блока, которые препятствуют ей взаимодействовать с другими сетями Substrate. Avail реализует независимую сеть, не связанную с Polkadot или Kusama.

:::

Avail обеспечивает высокую гарантию доступности данных любому клиенту света, но не обеспечивает более высоких гарантий для световых клиентов о DA, чем любая другая сеть. Avail делает ставку на возможность доказать, что данные блока доступны без загрузки всего блока путем использования обязательств Kate polynomial, кодирования удара, и других технологий, чтобы позволить светлым клиентам (которые загружают только _заголовки_ цепочки) эффективно и случайно отбирать небольшие количества данных блока для проверки его полной доступности. Однако существуют принципиально разные примитивы, чем системы DA, основанные на мошенничестве, которые объясняются [здесь](https://blog.polygon.technology/the-data-availability-problem-6b74b619ffcc/).

### Обеспечение доступности данных {#providing-data-availability}

Гарантия DA — это то, что определяет клиент для себя; ему не нужно доверять нодам. По мере роста числа клиентов они коллективно пробуют весь блок (хотя каждый клиент только продает небольшой процент). Клиенты Light в конечном итоге формируют сеть P2P; таким образом, после того, как блок был взят в выборку, он становится весьма доступным — даже если узлы должны были пойти вниз (или попытаться form блок), клиенты света смогут восстановить блок путем обмена фрагментами между собой.

### Обеспечение условий для следующего набора решений {#enabling-the-next-set-of-solutions}

Avail будет выводить rollups на следующий уровень, поскольку цепочки смогут передать свой компонент доступности данных в Avail. Avail также предоставляет альтернативный способ bootstrap любой автономной цепочки, поскольку цепочки могут вытеснить их доступность данных. Конечно, существуют компромиссы, которые сделаны с различными подходами модульности, но общая цель заключается в поддержании высокой безопасности при условии возможности масштабирования.

Кроме того, сокращаются расходы на транзакции. Avail может расти с меньшим влиянием на нагрузку валидатора, чем монолитная цепочка. Когда монолитная цепочка увеличивает размер блока, валидаторам приходится делать гораздо больше работы, потому что блоки должны выполняться, и состояние должен быть вычислен. Поскольку Avail не имеет среды исполнения, увеличить размер блока гораздо дешевле. Стоимость не нулевая, поскольку необходимо рассчитать обязательства в KZG и генерировать доказательства, но все еще недорого.

Avail также обеспечивает возможность использования суверенных свертков. Пользователи могут создавать суверенные цепочки, которые полагаются на валидаторов Avail, для достижения консенсуса по данным транзакции и порядку. суверенные rollups в Avail позволяют осуществлять бесшовные обновления, поскольку пользователи могут наталкивать обновления на конкретные для приложения узлы, чтобы обновить цепочку, а в свою очередь перейти на новую логику расчетов. А вот в традиционной среде сети требуется форк.

:::info Avail не имеет среды исполнения

Avail не запускает смарт-контракты, но позволяет другим цепочкам сделать данные транзакции доступными через Avail. Эти цепочки могут реализовать свои среды исполнения: EVM, Wasm или что-либо другое.

:::

Доступность данных в Avail доступна для окна времени, которое он требуется. Например, помимо необходимости данных или реконструкции, безопасность не подвергается угрозе.

:::info Для Avail не важно, для чего предназначены данные

Avail гарантирует, что данные блока доступны, но не волнует, что эти данные. Данные могут быть транзакциями, но могут принимать и другие формы.

:::

Системы хранения, напротив, предназначены для хранения данных в течение длительного периода и включают механизмы стимулирования для поощрения пользователей к хранению данных.

## Проверка {#validation}

### Одноранговая проверка {#peer-validation}

Экосистема обычно состоит из трех типов одноранговых узлов:

* **Узлы валидатора:** валидатор собирает транзакции из mempool, выполняет их, и генерирует блок кандидата, который добавляется в сеть. Блок содержит небольшой заголовок с дайджестом и метаданными транзакций в блоке.
* **Полные** узлы: Блок кандидата распространяется на полные узлы по сети для проверки. Ноды повторно исполняют транзакции, содержащиеся в блоке-кандидате.
* **Клиенты** Light могут получить только заголовок блока для проверки и будут получать данные транзакции из соседних полных нодов по мере необходимости.

Защищенный подход, Avail решает ограничения этой архитектуры, чтобы создать надежность и повысить гарантии. Клиенты Light могут быть обмануты в принимающие блоки, чьи базовые данные недоступны. Производитель блока может включать в блок вредоносную транзакцию, а не раскрывать весь контент в сети. Как упоминалось в документах Avail, это известно как проблема наличия данных.

В число сетевых узлов Avail входят:

* **Узлы валидатора:** Протокол стимулировал полные узлы, которые участвуют в консенсусе. Узлы валидатора в Avail не выполняют транзакции. Они упаковывают произвольные транзакции и создают блоки, генерирующие обязательства KZG для **данных. Другие валидаторы проверят, что генерируемые блоки являются правильными**.

* **Полный узел Avail (DA):** Узлы, которые загружают и предоставляют все данные блока для всех приложений с использованием Avail. Точно так же полные ноды Avail не исполняют транзакции.

* **Клиенты Avail (DA):** Клиенты, которые только загружают заголовки блока произвольно отображают небольшие части блока для проверки доступности. Они выставляют локальный API для взаимодействия с сетью Avail.

:::info Цель Avail заключается в том, чтобы не полагаться на полные ноды в обеспечении доступности данных

Цель заключается в том, чтобы дать аналогичные гарантии DA легкому клиенту в качестве полного нода. Пользователям настоятельно рекомендуется использовать тонкие клиенты Avail. Однако они все еще могут запустить полноформатные узлы Avail, которые хорошо поддерживаются.

:::

:::caution Локальный API в настоящее время разрабатывается и пока еще не является стабильным


:::

Это позволяет приложениям, которые хотят использовать Avail, чтобы встроить клиент DA. После этого они могут создать:

* **Полный узел**
  - Внедрить тонкий клиент Avail (для обеспечения доступности данных)
  - Загрузить все данные для конкретного appID
  - Реализовать среду исполнения для запуска транзакций
  - Поддерживать состояние приложения

* **Клиенты света приложения**
  - Внедрить тонкий клиент Avail (для обеспечения доступности данных)
  - Реализовать функциональность, рассчитанную на конечных пользователей

Экосистема Avail будет также содержать мосты, чтобы включить конкретные кейсы использования. Один из таких мостов, разрабатываемых в настоящее время, — это _аттестованный_ мост, который будет размещать данные в Avail в Ethereum, что позволит создать validiums.

## Проверка состояния {#state-verification}

### Проверка блока → Проверка DA {#da-verification}

#### Валидаторы {#validators}

Вместо валидаторов Avail, проверяющих состояние приложения, они концентрируются на обеспечении наличия данных размещенных транзакций и предоставлении ордера транзакции. Блок считается действительным только в случае доступности данных, лежащих в его основе.

валидаторы Avail берут входящие транзакции, заказывают их, создают блок кандидата и предлагают в сеть. Блок содержит специальные функции, особенно для кодирования DA—erasure и обязательств KZG. Это в конкретном формате, поэтому клиенты могут выполнять произвольный выбор, а также загружать только транзакции одного приложения.

Другие валидаторы проверяют блок путем обеспечения того, что блок правильно сформирован, обязательства KZG
совпадают, данные имеются в наличии и т. д.

#### Клиенты {#clients}

Требование данных, которые должны быть доступны, предотвращает производителей блоков освобождать заголовки блока без выпуска данных, которые позади, поскольку это не позволяет клиентам читать транзакции, необходимые для вычисления состояния их приложений. Как и в случае с другими цепочками, Avail использует проверку наличия данных для устранения этого с помощью проверок DA, которые используют коды стирания; эти проверки используются в конструкции резервирования данных.

Коды Erasure эффективно дублируют данные, чтобы при подавлении части блока клиенты могли восстановить эту часть с помощью другой части блока. Это значит, что ноду, пытающемуся скрыть эту часть, необходимо будет скрыть гораздо больше.

> Этот метод используется в таких устройствах, как CD-ROM и многодисковые (RAID) массивы (например,
> в случае отказа жесткого диска его можно заменить и реконструировать из данных на других дисках).

Что уникальна в Avail, так это то, что дизайн цепочки позволяет **любому** проверять DA, не нуждаясь в загрузке. Проверка DA требует, чтобы каждый клиент света мог выполнить выборку минимального количества случайных chunks из каждого блока в цепочке. Набор легких клиентов может коллективно опробовать весь блокчейн таким образом. Следовательно, чем больше не консенсусных узлов, тем больше размер блока (и пропускание) может быть безопасно существовать. Это означает, что узлы Meaning, могут способствовать пропускной способности и безопасности сети.

### Расчеты по транзакциям {#transaction-settlement}

Avail будет использовать уровень расчетов, созданный с помощью Polygon Edge. Уровень расчетов обеспечивает совместимый с EVM блокчейн для роллапов для хранения их данных и выполнения разрешения споров. Слои расчетов использует Polygon Avail для своего DA. Когда rollups используют слой расчета, они также наследуют все свойства DA Avail.

:::note Различные способы расчетов

Существуют различные способы использования Avail, и validiums будут использовать не слой расчета, а рассчитать на Ethereum.

:::

Avail обеспечивает размещение и упорядочивание данных. Уровень выполнения, вероятно, будет исходить из нескольких решений масштабирования вне цепочки или слоев выполнения. Уровень урегулирования берет на себя компонент проверки и разрешения споров.

## Информационные ресурсы {#resources}

- [Введение в Avail Polygon](https://medium.com/the-polygon-blog/introducing-avail-by-polygon-a-robust-general-purpose-scalable-data-availability-layer-98bc9814c048).
- [Беседы о Polygon: Polygon Avail](https://www.youtube.com/watch?v=okqMT1v3xi0)
